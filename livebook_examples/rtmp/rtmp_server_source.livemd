# RTMP Server Source

```elixir
File.cd(__DIR__)
# Logger.configure(level: :error)

Mix.install([
  {:membrane_core, "~>0.11.2"},
  {:membrane_realtimer_plugin, "~>0.6.1"},
  {:membrane_hackney_plugin, "~>0.9.0"},
  {:membrane_rtmp_plugin, "~>0.11.0"}
])
```

## Section

```elixir
defmodule RTMP.Server.Source do
  use Membrane.Pipeline

  @samples_url "https://raw.githubusercontent.com/membraneframework/static/gh-pages/samples/big-buck-bunny/"
  @video_url @samples_url <> "bun33s_480x270.h264"
  @audio_url @samples_url <> "bun33s.aac"

  @impl true
  def handle_init(_ctx, destination: destination) do
    video_source =
      child(:video_source, %Membrane.Hackney.Source{
        location: @video_url,
        hackney_opts: [follow_redirect: true]
      })
      |> child(:video_parser, %Membrane.H264.FFmpeg.Parser{
        framerate: {25, 1},
        alignment: :au,
        attach_nalus?: true,
        skip_until_keyframe?: true
      })
      |> child(:video_realtimer, Membrane.Realtimer)
      |> child(:video_payloader, Membrane.MP4.Payloader.H264)
      |> via_in(:video)
      |> get_child(:rtmp_sink)

    audio_source =
      child(:audio_source, %Membrane.Hackney.Source{
        location: @audio_url,
        hackney_opts: [follow_redirect: true]
      })
      |> child(:audio_parser, %Membrane.AAC.Parser{
        in_encapsulation: :ADTS,
        out_encapsulation: :none
      })
      |> child(:audio_realtimer, Membrane.Realtimer)
      |> via_in(:audio)
      |> get_child(:rtmp_sink)

    rtmp_target =
      child(:rtmp_sink, %Membrane.RTMP.Sink{rtmp_url: destination, max_attempts: :infinity})

    structure = [video_source, audio_source, rtmp_target]

    {[spec: structure, playback: :playing], %{streams_to_end: 2}}
  end

  # The rest of the example module is only used for self-termination of the pipeline after processing finishes
  @impl true
  def handle_element_end_of_stream(:rtmp_sink, _pad, _ctx, %{streams_to_end: 1} = state) do
    {[terminate: :shutdown], %{state | streams_to_end: 0}}
  end

  @impl true
  def handle_element_end_of_stream(:rtmp_sink, _pad, _ctx, state) do
    {[], %{state | streams_to_end: 1}}
  end

  @impl true
  def handle_element_end_of_stream(_child, _pad, _ctx, state) do
    {[], state}
  end
end

:ok
```

```elixir
alias Membrane.RemoteControlled, as: RC

port = System.get_env("RTMP_PORT", "1936")
destination = "rtmp://localhost:#{port}"

{:ok, _supervisor, pipeline} = RTMP.Server.Source.start(destination: destination)

RTMP.Server.Source.terminate(pipeline, blocking?: true)
```
