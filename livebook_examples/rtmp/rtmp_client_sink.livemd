# RTMP Client Sink

```elixir
File.cd(__DIR__)
Logger.configure(level: :error)

Mix.install([
  # {:membrane_kino_plugin, github: "membraneframework-labs/membrane_kino_plugin"},
  {:membrane_kino_plugin, path: "../../../membrane_kino_plugin"},
  {:membrane_core, "~>0.11.2"},
  {:membrane_realtimer_plugin, "~>0.6.1"},
  {:membrane_rtmp_plugin, "~>0.11.0"}
])
```

## Section

```elixir
defmodule Pipeline do
  use Membrane.Pipeline

  # @output_file "received.flv"

  @impl true
  def handle_init(_ctx, socket: socket, kino: kino) do
    structure = [
      child(:source, %Membrane.RTMP.SourceBin{
        socket: socket
      }),
      child(:sink, %Membrane.Kino.Player.Sink{kino: kino}),
      get_child(:source)
      |> via_out(:audio)
      |> child(:audio_parser, %Membrane.AAC.Parser{
        in_encapsulation: :none,
        out_encapsulation: :ADTS
      })
      |> via_in(:audio)
      |> get_child(:sink),
      get_child(:source)
      |> via_out(:video)
      |> child(:video_parser, %Membrane.H264.FFmpeg.Parser{
        framerate: {25, 1}
      })
      |> via_in(:video)
      |> get_child(:sink)
    ]

    {[spec: structure, playback: :playing], %{}}
  end

  # Once the source initializes, we grant it the control over the tcp socket
  @impl true
  def handle_child_notification(
        {:socket_control_needed, _socket, _source} = notification,
        :source,
        _ctx,
        state
      ) do
    send(self(), notification)

    {[], state}
  end

  def handle_child_notification(_notification, _child, _ctx, state) do
    {[], state}
  end

  @impl true
  def handle_info({:socket_control_needed, socket, source} = notification, _ctx, state) do
    case Membrane.RTMP.SourceBin.pass_control(socket, source) do
      :ok ->
        :ok

      {:error, :not_owner} ->
        Process.send_after(self(), notification, 200)
    end

    {[], state}
  end

  # The rest of the module is used for self-termination of the pipeline after processing finishes
  @impl true
  def handle_element_end_of_stream(:sink, _pad, _ctx, state) do
    {[terminate: :shutdown], state}
  end

  @impl true
  def handle_element_end_of_stream(_child, _pad, _ctx, state) do
    {[], state}
  end
end

:ok
```

```elixir
defmodule Example do
  @server_ip {127, 0, 0, 1}

  def run(port: port, kino: kino) do
    parent = self()

    server_options = %Membrane.RTMP.Source.TcpServer{
      port: port,
      listen_options: [
        :binary,
        packet: :raw,
        active: false,
        ip: @server_ip
      ],
      socket_handler: fn socket ->
        # On new connection a pipeline is started
        {:ok, _supervisor, pipeline} = Pipeline.start_link(socket: socket, kino: kino)
        send(parent, {:pipeline_spawned, pipeline})
        {:ok, pipeline}
      end
    }

    Membrane.RTMP.Source.TcpServer.start_link(server_options)

    pipeline =
      receive do
        {:pipeline_spawned, pid} ->
          pid
      end

    ref = Process.monitor(pipeline)

    receive do
      {:DOWN, ^ref, :process, _obj, _reason} ->
        :ok
    end
  end
end

:ok
```

```elixir
kino = Membrane.Kino.Player.new(:both)
```

```elixir
Example.run(port: 1941, kino: kino)
```
